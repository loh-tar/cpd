#!/bin/bash
#
#   cpd - The Copy Daemon
#
#   Copyright (C) 2017 loh.tar@googlemail.com
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#   MA 02110-1301, USA.

declare -r version="0.1pre9"
declare -r vDate="Dez 2017"

declare -r me=$(basename $(readlink -e $0 ))
declare    alterEgo=$(basename "$0")
if [[ "$me" == "$alterEgo" ]] ; then
declare -r isAlterEgo="0"
alterEgo="cpc"                                  # Only because to ease help printing
else
declare -r isAlterEgo="1"
fi
readonly alterEgo

declare    optRecursive="0"
declare    optMerge="0"
declare    optSimulation="0"
declare    optExtraCopy=""
declare    optSourceList=""
declare    optUserPrio="0"
declare    optIdleTime="600"
declare    optStartDaemon="0"
declare    optForcedScreenSize="0"

declare -r tmpDir="/tmp/$me/user-$(id -un)"
declare -r jobFile="$tmpDir/jobs"               # All jobs as key/value
declare -r jobList="$tmpDir/joblst"             # Subset of jobFile as handy table
declare -A jobData=()                           # Will filled with data of jobFile
declare -A jobPids=()                           # PIDs of our jobs by our own ID
declare    recheckJobList="0"                   # Set to 1 when some job has finished
declare    stopRunning="0"                      # Set to 1 by command 'exit'
declare    screenWidth="0"                      # Will adjusted by setScreenWidth()
declare    daemonPID="0"                        # Used to notify/check our Daemon

# Colored text and other escape sequences
# FIXME: Add test if terminal is capable of colored output
declare    txtBold=$'\e[1m'                     # Or bright, depend on your terminal
declare    txtClean=$'\e[0m'                    # All attributes off
declare    clearLine=$'\e[2K'                   # Äh, yes
declare    oneLineUp=$'\e[1A'                   # Need more lines? 3A=three lines up

#
# Helper Functions
#
fitToScreen() {
  # Need parms: fileDescriptor textToCut

  # I have no clue if there is an easier way to achieve this what here is done,
  # but I like it currently, just because it's build on my own and works nicely.
  # This is not enough: txt=$(cut -c-$screenWidth <<< $txt)
  # It was fun to solve this problem, just as cpd as a whole

  local inTerminal="0"
  local -n txt="$2"
  local txtWidth="${#txt}"
  local copy

  stripMost() {
    # Strip all stuff which not affect the display length
    copy="$txt"
    copy="${copy//[$'\r']}"                       # No tab handling, sorry
    copy="${copy//${clearLine}}"

#   This way works, but if we have many colors it would be annoying all to list
#   copy="${copy//${txtBold}}"
#   copy="${copy//${txtClean}}"
#   ...
#   FIXME That's why I tried to do it like Luke in printFile and sed, but didn't got it perfect
#   copy="${copy//$'\e['[0-9]*m?}"  # Removes first colored char of word
#   copy="${copy//$'\e['[0-9]+m?}"  # No effect
#   copy="${copy//$'\e['[0-9]*m}"   # Removes complete colored word
    copy="${copy//$'\e['[0-9]m}"    # Works but would not catch two numbered colors like colRed=$'\e[31m'

    txtWidth="${#copy}"
  }

  stripRest() {
    copy="${copy//[$'\n']}"
    txtWidth="${#copy}"
  }

  if [[ ! -t "$1" ]] ; then
    # Remove colors when output is piped
    stripMost
    txt="$copy"
    # Anyway cut to screen, except if set to < 0 or we have no clue about the screen
    # Using tilde as hint char because of no colors it looks not so confusing
    (( screenWidth < txtWidth && screenWidth > 0 )) && txt="${txt:0:${screenWidth}-1}~"
    return
  fi

  (( screenWidth < 1 ))         && return       # Unknown screen/forced cut option, nothing todo
  (( screenWidth >= txtWidth )) && return       # Nothing todo

  stripMost; stripRest

  (( screenWidth >= txtWidth )) && return       # Gotcha! Still nothing todo

  # Save some special line end
  local completion=""
  [[ "$txt" =~ [$'\n\r']$ ]] && completion="${txt: -1}"
  overmuch="${copy:${screenWidth}-1}"           # One less for the later hint char '>'

  # Cutting is very tricky due to possible included escape sequences
  local cutted
  while : ; do
    cutted="${txt/%${overmuch}}"                # Try to cut from the end
    (( ${#cutted} < ${#txt} )) && break         # Bingo!
    # Cut one char from our piece of overmuch
    overmuch="${overmuch:0: -1}"
    # Cut one char from our message too
    txt="${txt:0: -1}"
    (( ${#overmuch} == 0 )) && break            # Nothing left, we are done
    # Now the tricky part, cut message as long the last char of both not match!
    while [[ "${overmuch: -1}" != "${txt: -1}" ]] ; do txt="${txt:0: -1}"; done
  done

  # Paste a highlighted hint to the cropped txt
  txt="${cutted}${txtBold}>${txtClean}${completion}"
}

write() {
  # Need parms: fileDescriptor [format] text
  local fd="$1"; shift
  local format="%b"
  (( $# > 1 )) && { format="$1"; shift; }
  local msg

  printf -v msg "$format" "$@"
  fitToScreen $fd msg
  printf "%s" "$msg"
}

out() {
  write "1" "$@"
  printf "\n"
}

error() {
  out "Error: $1" >&2
}

info() {
  write "2" "$@" >&2
}

exitGood() {
  info "$1\n"
  exit 0
}

exitError() {
  error "$*"
  exit 1
}

printFile() {
  local sw="$screenWidth"
  (( sw < 1 )) && sw="9999"

  if [[ -t 1 ]] ; then
    cut "-c-$sw" "$@" 2>/dev/null
  else
    # Because I like to keep my highlighted stuff in the daemon log, I remove
    # these colors now when running e.g. in a pipe. Yeah, sounds pretty stupid...

    # Thanks Luke, the force is with you
    # https://stackoverflow.com/a/24005600
    sed -r 's/\x1b\[[0-9;]*m?//g' "$@" 2>/dev/null | cut "-c-$sw"
  fi
}

checkTmpDir() {
  [[ -d "$tmpDir" ]] && return

  mkdir -p -m 700 "$tmpDir"
  touch "$jobFile"
  touch "$jobList"
  echo "1" > "$tmpDir/next-id"
  unLock
}

check4PosInteger() {
  [[ "$1" =~ ^[0-9]+$ ]] || exitError "Not a positive integer: $1"
}

check4Integer() {
  [[ "$1" =~ ^-?[0-9]+$ ]] || exitError "Not my kind of integer: $1"
}

check4Jobs() {
  [[ -s "$jobFile" ]] && return

  local cmd="${FUNCNAME[1]:3}"; cmd="${cmd,,[A-Z]}"
  [[ "$cmd" == "changeprio" ]] && cmd="change PRIO"
  exitGood "No jobs to $cmd"
}

isDelta() {
  [[ "$1" =~ ^[+-][0-9]+$ ]] && return 1 || return 0
}

isGNUcopy() {
  # TODO Test this if it works as intended when running on non GNU/Linux system
  cp --version 2>/dev/null |grep -q GNU
}

checkJobId() {
  check4PosInteger "$1"

  [[ $(cut -d' ' -f1 "$jobFile" | grep -c "$1") -eq 0 ]] &&
    exitError "Job not found: $1"
}

checkStatus() {
  # Need parms: id status change
  local status=$(getJobValue "$1" "STATUS")
  local change=${3-"change"}
  [[ "$status" == "$2" ]] || exitError "Job $1 is '$status', you can only $change '$2' jobs"
}

unLock(){
  rm "$tmpDir/locked-by"  2>/dev/null
  touch "$tmpDir/not-locked"
}

setLock() {
  # Call setLock only from top level functions like cmdFoo,
  # we want protect from second process not the own process
  # Mutex functionality inspired by
  # http://mywiki.wooledge.org/BashFAQ/045

  local i=0 freeTry=3

  while : ;
  do
    if rm "$tmpDir/not-locked" 2>/dev/null
    then
      echo "Locked by $alterEgo pid $$ at $(date -Is)" > "$tmpDir/locked-by"
      (( i >= freeTry )) && info "OK\n"
      return 0 # Good!
    else
      (( i++ ))
      # Try some without to print info
      if (( i > freeTry ))
        then info "."
      elif (( i == freeTry ))
        then
          local who=$(cut -d' ' -f3 "$tmpDir/locked-by" 2>/dev/null)
          local pid=$(cut -d' ' -f5 "$tmpDir/locked-by" 2>/dev/null)
          if [[ -f "$tmpDir/locked-by" ]] ; then
            local pid2=($(ps -C $who -o pid=))
            if [[ "${pid2[*]}" =~ "$pid" ]] ; then
              info "Try to lock..."
            else
              info "Oops?! Lock owner not found. Looks like a state after some crash\n"
              unLock; let i=0
            fi
          else
            info "Oops?! No 'locked-by'. Looks like a state after some crash\n"
            unLock; let i=0
          fi
      fi

      sleep $(echo "0.3 + 0.4 * $i" | bc)
      if (( i == 7 )) ; then
        info "FAIL!\n"
        error "Can't get lock\n$(cat "$tmpDir/locked-by" 2>/dev/null)"
        return 1 # Bad!
      fi
    fi
  done
}

nextJobId() {
  local id

  read id < "$tmpDir/next-id"
  echo "$(( id + 1 ))" > "$tmpDir/next-id"
  echo "$id"
}

addToJobFile() {
  # Need parms: id key value
  printf "%s:%s:%s\n" "$1" "$2" "$3" >> "$jobFile"
}

updateJobList() {
  # Do NOT call updateJobList after add or change a job!
  # That would confuse processJobList
  [[ -s "$jobFile" ]] || return
  readJobs
  rm -f "$jobList"

  read max < "$tmpDir/next-id"
  for (( id=1; id < max; id++ ))
  do
#   echo "$id" "${jobData["$id:STATUS"]}" "${jobData["$id:DRIVE"]}"
    printf "%s %s %s %s %s\n"                                 \
      "$id" "${jobData["$id:PRIO"]}" "${jobData["$id:DATE"]}" \
      "${jobData["$id:STATUS"]}" "${jobData["$id:DRIVE"]}"    \
      >> "$jobList"
  done

  sort -k 2,3 "$jobList" > "$jobList-tmp"
  mv "$jobList-tmp" "$jobList"
}

modifyJob() {
  # Need parms: id key newValue
  sed -i -e "s,^\($1:$2:\).*,\1$3," "$jobFile"
}

getJobValue() {
  # Need parms: id key, Returns value
  local line=$(grep "^$1:$2:" "$jobFile")
  echo ${line#[0-9]*:[A-Z]*:} # No quotes here removes unneeded spaces
}

changeStatus() {
  # Need parms: id newStatus
  modifyJob $1 "STATUS" $2

  if [[ "STOPPING CANCEL" =~ $2 ]] ; then
    modifyJob $1 "PRIO" "0"
  elif [[ "running starting" =~ $2 ]] ; then
    modifyJob $1 "PRIO" "1"
  elif [[ "RESUME STOPPED" =~ $2 ]] ; then
    modifyJob $1 "PRIO" "2"
  elif [[ "canceled killed ERROR NOSTART" =~ $2 ]] ; then
    modifyJob $1 "PRIO" "8"
  elif [[ "done" =~ $2 ]] ; then
    modifyJob $1 "PRIO" "9"
  fi
}

readJobs() {
  local key val

  while read line
  do
    val=${line#[0-9]*:[A-Z]*:}
    key=${line%:${val}}
    jobData[$key]=$val
  done < "$jobFile"
}

setScreenWidth() {
  (( optForcedScreenSize )) && return
  (( COLUMNS )) && { screenWidth="$COLUMNS"; return; }
  screenWidth=$(stty size 2>/dev/null |cut -d' ' -f2)
}

cutLeft() {
  # Need parms: width string

  # Some effort to cut string from the left side to fit into table
  # I did't get it with some printf format :-/
  local -n str=$2       # -n =by reference
  local length=${#str}

  (( length > $1 )) && str="~${str:((length - $1 + 1)):$length}"
}

#
# Command Implementations
#
cmdHelp() {
  case $1 in
    l)  out ""
        # Adjust -B4 in case of copyright changes
        grep -B4 -A13 -m1 "This program is free software" "$0" | cut -b2-
        out ""
    ;;
    s)  less "$0"
    ;;
    *)  if [[ $1 == "H" ]] ; then
        out "This is ${txtBold}$me${txtClean} - The copy daemon (v$version, $vDate)"
        (( isAlterEgo )) && out "Running as alter ego '${txtBold}$alterEgo${txtClean}' with limited range"
        out ""
        fi
        out "${txtBold}Usage:${txtClean}"
        if (( isAlterEgo )) ; then
        local who="$alterEgo"
        else
        local who="$me"
        local extra=" newjob"
        out "  $who [option>...] <command> [<argument>...]"
        fi
#         out "  $who [option>...]$extra <source> <destination>"      # TODO
#         out "  $who [option>...]$extra <source>... <dest-dir>"      # TODO
        out "  $who [option>...]$extra <dest-dir> <source>..."        # DELETE
#         out "  $who [option>...]$extra -t <dest-dir> <source>..."   # TODO
        out "  $who [option>...]$extra <dest-dir>                   # Read list of sources from stdin"
        out "  $who [option>...]$extra -f <file> <dest-dir>"
#         [[ $1 == "H" ]] && out ""
#         out "  -v                       Be verbose" # TODO
#         out "  -q                       Be almost quiet" # TODO
        [[ $1 == "H" ]] && out ""
        out "${txtBold}Options:${txtClean}"
        out "  -a                       Auto start the daemon if not already running"
        if [[ $1 == "H" ]] ; then
        out "  -h                       Print less help"
        out "  -c <cols>                Force output to cut at <cols>, 0 or negative=no cut"
        else
        out "  -H                       Print more help"
        fi
        out "  -f <file>                Read list of source files from <file>"
        out "  -i <idle-time>           Daemon stand by time in seconds, default=600, unlimited=-1"
        out "  -o <cp-opt>              Add <cp-opt> to the called cp command. Disables -r/-m if given"
        out "  -p <user-prio>           Enqueue job with modified default priority. PRIO=6 minus <user-prio>"
        out "  -s                       Run a simulation, copy nothing"
        if isGNUcopy ; then
        out "  -m                       Merge all files in <dest-dir>. Ignored if -o is given"
        out "  -r                       Copy recursive. Ignored if -o is given"
        fi
        if (( ! isAlterEgo )) ; then
        [[ $1 == "H" ]] && out ""
        out "${txtBold}Commands:${txtClean}"
        if [[ $1 == "h" ]] ; then
        out "  h, help [c]              Show this help or when c=l License, c=s Source of ${txtBold}$me${txtClean}"
        out "  H                        Show more help"
#         out "  o, option o[-|<arg>]     Set an option for further use until unset by o- (o an option letter without hyphen)" # TODO
        else
        out "  h, help [c]              Show less help or when c=l License, c=s Source of ${txtBold}$me${txtClean}"
        out "  H                        Show this help"
        fi
        out "     newjob <arguments>    Enqueue a new job with arguments as shown above"
        out "     start                 Start the daemon and job processing"
        out "  X, exit                  Terminate the daemon and job processing"
        out "  P, process               Process jobs in foreground or trigger daemon to continue"
#         out "  P, process               Process jobs in foreground" TODO
        out "  K, kill <job>...         Kill a running or cancel a pending job"
        out "  p, prio <prio> <job>...  Change job PRIO to <prio> or 'PRIO=PRIO minus <prio>' if +-<prio>"
        out "  r, resume <job>...       Resume jobs"
        out "  w, show [c]              Show jobs, c=i by ID, c=e errors, c=l job log, c=s daemon status"
        out "  s, stop <job>...         Stop jobs"
        out "  Y, tidy                  Tidy up all job data"
#         out "  y, Tidy                 Tidy up done jobs (TODO)"
        fi
        if [[ $1 == "H" ]] ; then
        out ""
        out "${txtBold}Notes:${txtClean}"
        if (( ! isAlterEgo )) ; then
        out "  • Calling $me with any ${txtBold}other name${txtClean} than ${txtBold}$me${txtClean}" \
                "forces to run as if ${txtBold}newjob${txtClean} was given"
        out "  • The ${txtBold}<command>${txtClean} is fuzzy recognized by any parts of its long name"
        out "  • Short commands which take an argument can written without a space, ${txtBold}handy huh?${txtClean}"
        out "  • The job ${txtBold}PRIO${txtClean} is not static. Lower numbers have a higher priority"
        out "    - Jobs started in order of PRIO and ${txtBold}enqueue time${txtClean}"
        out "    - Intern used is: 0 need attention, 1 running, 2 stopped, 8 error/killed, 9 done"
        out "  • ${txtBold}exit${txtClean} stops job processing, if so, or stops the daemon at all, if not"
        out "    - Adding a new job trigger the daemon to continue job processing, there is no blocking"
        out "  • ${txtBold}tidy${txtClean} does nothing else than ${txtBold}'rm -rf $tmpDir'${txtClean}"
        out "  • With ${txtBold}-s${txtClean} will only run a sleep/forced-error job with a crude chosen time of a few seconds."
        fi
        out "  • Enclose ${txtBold}<cp-opt>${txtClean} in quotes if you need more than one option"
        out "  • New jobs have prio 6 unless ${txtBold}-p${txtClean} was given"
        out ""
        out "${txtBold}Examples:${txtClean}"
        if (( ! isAlterEgo )) ; then
        out "  Enqueue a new job"
        out "    $me new /media/1a/foo *"
        out ""
        out "  Enqueue a new job, assumed you have a symlink $alterEgo->$me"
        else
        out "    $alterEgo /media/1a/foo *"
        fi
        out "    $alterEgo -p1 /media/1b/foo *                       # New job with higher PRIO=5"
        out "    $alterEgo /media/1c/foo < /path/to/list-of-files"
        out "    find * -type f -print | $alterEgo -p2 /media/1d/foo"
        if (( ! isAlterEgo )) ; then
        out ""
        out "  Start the daemon in simulation mode with no stand by time, will exit when all is done"
        out "    $me -si0 start"
        out ""
        out "  Take a look how it is going"
        out "    watch -n1 $me w"
        out "    watch -n1 $me ws"
        fi
        fi
    ;;
  esac
}

outJobLine() {
  local id="$1"
  local format="$2"

  local target="${jobData["$1:TARGET"]}"
  cutLeft "20" target

  printf -v txt "$format"                                     \
    "$id" "${jobData["$id:PRIO"]}" "${jobData["$id:STATUS"]}" \
    "${jobData["$id:SIZE"]}" "${jobData["$id:DRIVE"]}"        \
    "$target" "${jobData["$id:FILES"]}"

  out "$txt"
}

showStatus() {
  if [[ -s "$jobFile" ]] ; then
    out "Jobs by status:"
    for s in "Running" "Error" "NoStart" "Pending" "Killed" "Canceled" "Done"
    do
      # Grepping lines like:  1:STATUS:foobar
      local jobCount=$(grep -i "STATUS:$s" "$tmpDir/jobs" | wc -l)
#       (( jobCount )) || continue
      local -a jobs=($(grep -i "STATUS:$s" "$tmpDir/jobs" | cut -d: -f1))
      printf -v txt "  %-8s %5s: %s" "$s" "($jobCount)" "${jobs[*]}"
      out "$txt"
    done
  else
    out "No jobs"
  fi

  out ""

  if getDaemonPid ; then
    out "Daemon is running with pid $daemonPID"
    printFile "$tmpDir/processStatus"
    out " " # The blank is needed!

    # Thanks to Daniel
    # https://unix.stackexchange.com/a/325581
    if compgen -G "$tmpDir/job-status-*" > /dev/null; then
      out "Running jobs:"
      printFile "$tmpDir"/job-status-*
    fi
  else
    out "No running daemon"
  fi

}

cmdShow() {
  # TODO: Add more options for different kind of display. The are so much
  # possibilities: filters, sort order, show as ticket, selected fields...
  local type="$1"
  [[ -s "$jobFile" ]] || type="NoJobs"
  [[ "$1" == "s"   ]] && type="showStatus"

  setScreenWidth

  case "$type" in
    e|-le)
      read max < "$tmpDir/next-id"
      for (( id=1; id < max; id++ ))
      do
        [[ -s "$tmpDir/error.log-job-$id" ]] || continue
        out ">>>>> Error log of job $id"
        printFile "$tmpDir/error.log-job-$id"
        out ""
      done
      ;;

    l|-ll)
      printFile "$tmpDir/job.log"
      ;;

    NoJobs)
      out "No jobs to list"
      ;;

    showStatus)
      showStatus
      ;;

    *)
      local txt=" ID PRIO STATUS   SIZE  DRIVE            TARGET                FILES"
      local format="%3s   %s  %-8s %4s  %-15s  %-20s  %s"
      out "$txt"
      readJobs
      ;;&

    i|-li)
      read max < "$tmpDir/next-id"
      for (( id=1; id < max; id++ ))
      do
        outJobLine "$id" "$format"
      done
      ;;

    *)
      setLock || exit 1
      updateJobList
      unLock

      while read id prio date status drive
      do
        outJobLine "$id" "$format"
      done < "$jobList"
      ;;

  esac
}

getDaemonPid() {
  # Check if daemon is running
  if [[ -f "$tmpDir/daemon-pid" ]] ; then
    daemonPID=$(< "$tmpDir/daemon-pid")
    [[ -z "$daemonPID" ]] && exitError "FATAL: Empty pid file" # Should never happens
    local pid2=($(ps -C $me -o pid=))
    [[ "${pid2[*]}" =~ "$daemonPID" ]] && return 0
    info "Oops?! Daemon not found. Looks like a state after some crash\n"
  fi

  daemonPID="0"
  return 1
}

notifyDaemon() {
  # Instead of notify the daemon, it would be possible to cancel/resume/stop
  # the job directly. I don't know whats best, you?

  if getDaemonPid ; then
    kill -USR1 "$daemonPID"
    return 0
  elif (( optStartDaemon )) ; then
    cmdStartDaemon
    # Give daemon a little time to come up and give user a clean prompt
    sleep 1; echo
    return 0
  else
    # info "Hint: No running daemon\n"
    return 1
  fi
}

cmdKill() {
  # Need parms: id...
  check4Jobs
  setLock || exitError "No jobs killed"

  for jobId ; do
    if (( $(getJobValue "$jobId" "PRIO") > 7 )) ; then
      info "Ignore old job: $jobId ($(getJobValue "$jobId" "STATUS"))\n"
      continue
    fi

    out "Kill job $jobId: $(getJobValue $1 "FILES")"
    changeStatus "$jobId" "CANCEL"
  done

  unLock

  notifyDaemon
}

cmdResume() {
  # Need parms: id...
  check4Jobs
  setLock || exitError "No jobs resumed"

  for jobId ; do
    local status="$(getJobValue "$jobId" "STATUS")"
    if [[ "$status" != "STOPPED" ]] ; then
      info "Ignore not STOPPED job: $jobId ($status)\n"
      continue
    fi

    out "Resume job $jobId"
    changeStatus "$jobId" "RESUME"
  done

  unLock

  notifyDaemon
}

cmdStop() {
  # Need parms: id...
  check4Jobs
  setLock || exitError "No jobs stopped"

  for jobId ; do
    local status="$(getJobValue "$jobId" "STATUS")"
    if [[ "$status" != "running" ]] ; then
      info "Ignore not running job: $jobId ($status)\n"
      continue
    fi

    out "Stop job $jobId"
    changeStatus "$jobId" "STOPPING"
  done

  unLock

  notifyDaemon
}

cmdChangePrio() {
  # Need parms: id prio
  check4Jobs
  (( $# < 2 )) && exitError "Need two arguments"

  local prio="0" delta="0"

  adjustPrio() {
    local -n p="$1"
    (( p > 7 )) && { info "Adjust PRIO from $p to 7\n"; p="7"; }
    (( p < 3 )) && { info "Adjust PRIO from $p to 3\n"; p="3"; }
  }

  if isDelta "$1"; then
    check4PosInteger "$1"
    prio="$1"
    adjustPrio "prio"
  else
    delta="$1"
  fi

  shift

  for jobId ; do check4PosInteger "$jobId"; done

  setLock || exitError "No job changed"

  for jobId ; do
    if [[ $(getJobValue "$jobId" "STATUS") != "pending" ]] ; then
      info "Ignore not pending job: $jobId\n"
      continue
    fi

    oldPrio=$(getJobValue "$jobId" "PRIO")
    let newPrio=oldPrio-delta
    (( prio )) && let newPrio=prio
    adjustPrio "newPrio"
    out "Change priority of job $jobId from $oldPrio to $newPrio"
    modifyJob $jobId "PRIO" $newPrio
  done

  unLock
}

cmdTidy() {
  getDaemonPid && exitError "You like it tidy? Get rid of the beast first!"
  [[ -d $tmpDir ]] || exitGood "Nothing to tidy up"

  setLock || exitError "Oops!? I will better do nothing"

  rm -rf $tmpDir
  exitGood "Everything removed"
}

cmdProcess() {
  notifyDaemon && exitGood "Running daemon with pid $daemonPID is triggered to do the job"
  (( optSimulation )) && info "${txtBold}Running a simulation, nothing will copied${txtClean}\n"

  check4Jobs
  checkTmpDir
  cd "$tmpDir"
  set -o monitor
  trap "recheckJobList=1; info '${clearLine}Signaled* New or changed jobs *\n'" USR1 2>/dev/null
  trap "stopRunning=1; info '${clearLine}Received signal to stop, will wait for running jobs\n'" USR2 2>/dev/null
  trap checkChilds CHLD
  trap "rm $tmpDir/daemon-pid" EXIT

  echo "$$" > "$tmpDir/daemon-pid"
  recheckJobList="1"

  while (( recheckJobList ))
  do
    (( ! ${#jobPids[*]} && stopRunning )) && break
    processJobList
  done

  if (( stopRunning )) ; then
    info "Processing aborted by signal\n"
    stopRunning="0"
  else
    info "All done\n"
  fi
}

cmdStartDaemon() {
  # Thanks to Mike S
  # https://stackoverflow.com/a/29107686
  local meFullPath=$(readlink -e ${BASH_SOURCE[0]})

  case "$1" in
    DAEMON) # 3. doomed
      checkTmpDir
      exec >"$tmpDir/daemon-out.log"
      exec 2>"$tmpDir/daemon-error.log"
      exec 0</dev/null

      printf "%(%FT%T)T $me daemon started with pid $$\n" "-1"
      (( optSimulation )) && printf "*\n* Running in simulation mode, nothing will copied\n*\n"

      local txt="Idle time is"
      local sleepTime="1"
      if   (( optIdleTime == 0)) ; then
        local kickMe=" - will terminate immediately"
      elif (( optIdleTime < 0 )) ; then
        local kickMe=" - will not get out without a kick"
        optIdleTime="-1"  # Overwrite maybe lower user numbers
        sleepTime="5"     # Relieve a little the system :-)
      fi
      printf "%(%FT%T)T %s %ss %s\n" "-1" "$txt" "$optIdleTime" "$kickMe"

      # Mike suggest to run a daemon in / but I think that should be ok
      cd "$tmpDir"

      # FIXME: This part is almost a copy of cmdProcess,
      # split it into parts/functions to reduce redundancy
      set -o monitor
      trap "recheckJobList=1; printf '%(%FT%T)T Signaled* New or changed jobs *\n' '-1'" USR1 2>/dev/null
      trap "stopRunning=1; printf '%(%FT%T)T Signaled! I have to stop, will wait for running jobs\n' '-1'" USR2 2>/dev/null
      trap checkChilds CHLD
      trap "rm $tmpDir/daemon-pid" EXIT

      echo "$$" > "$tmpDir/daemon-pid"
      recheckJobList="1"

      local i="1"
      local boredTime=$(bc <<< "scale=0; $optIdleTime / 1.3")
      while (( ! stopRunning && i != 0 ))
      do

        (( recheckJobList )) && printf "%(%FT%T)T Go to work\n" "-1"

        while (( recheckJobList ))
        do
          (( ! ${#jobPids[*]} && stopRunning )) && break
          processJobList
          i="$optIdleTime"
        done

        # We want not fill the log with too much alive notes, but a little fun is welcome
        if (( i == optIdleTime )) ; then
          printf "%(%FT%T)T %s%s\n" "-1" "Gone idle" "$kickMe" >> "$tmpDir/processStatus"
          printf "%(%FT%T)T Gone idle\n" "-1" # Logfile
        elif (( i < 0 )) ; then
          let i=-1
        elif (( i < boredTime )) ; then
          head -n1 "$tmpDir/processStatus" > "$tmpDir/processStatus-$$"
          printf "%(%FT%T)T It's so boring...%s\n" "-1"  "$i" \
                  >> "$tmpDir/processStatus-$$"
          mv "$tmpDir/processStatus-$$" "$tmpDir/processStatus"
        fi

        # BUG Improve communication with daemon. Read from FIFO or something
        # instead. Now, if the signal arrives just short before we set these
        # variables the info is lost. Happens rarely but, if it is ugly
        stopRunning="0"
        recheckJobList="0"
        sleep $sleepTime
        (( optIdleTime != 0 )) && (( i-- ))
      done

      printf "%(%FT%T)T Good bye and have a nice day\n" "-1"
    ;;

    BANISHMENT) # 2. child
      # umask 0 # Mike does this, but for now we don't want a daemon running
                # as an other user than the caller (?)
      (( optSimulation )) && local simOrNot="-s"
      $meFullPath $simOrNot -i $optIdleTime start DAEMON  >/dev/null 2>/dev/null </dev/null &
      # FIXME: Print to tty like Mike, No \n, for now
      info "$me daemon started with pid $!"
    ;;

    *) # 1. entry point
      getDaemonPid && { info "Daemon is already running with pid $daemonPID\n"; exit 0; }
      if (( optSimulation )) ; then
        info "Start daemon in simulation mode, nothing will copied\n"
        local simOrNot="-s"
      fi
      setsid $meFullPath $simOrNot -i $optIdleTime start BANISHMENT  &
    ;;
  esac
}

cmdExit() {
  getDaemonPid || exitGood "No running daemon to stop"
  kill -USR2 "$daemonPID"
  setScreenWidth
  # Let's do some fancy stuff
  local  x=("-" "\\" "|" "/")  i="0"
  while [[ -f "$tmpDir/daemon-pid" ]] && (( i < 30 ))
  do
    # local txt=<("$tmpDir/processStatus")      # Not working, something locked
    # local txt=$(cat "$tmpDir/processStatus")  # Works
    # FIXME: Print three lines info text and hourglass (fix at processJobList too)
    #        and wait until key pressed
    # info "\r%s Wait for daemon with pid $daemonPID to stop %s" "${x[((i++ % 4))]}" "$txt"
    # info "$oneLineUp\r$clearLine%s  %s\nWait for daemon with pid $daemonPID to stop %s" "${x[((i++ % 4))]}" "$txt"
    info "\r%s Wait for daemon with pid $daemonPID to stop " "${x[((i++ % 4))]}"
    sleep 0.3;
  done

  if [[ -f "$tmpDir/daemon-pid" ]] ; then
    info " - is still running\n"
    printFile "$tmpDir/processStatus"
    exit 1
  else
    info " - OK\n"
    exit 0
  fi
}

#
# Here is the Beef!
#

startJob() {
  # Need parms: id
  procInfo "$1" "Start"
  changeStatus "$1" "starting"

if (( ! optSimulation )) ; then
  if ! cd "${jobData["$1:HOME"]}" 2>/dev/null ; then
    error "Job home is gone: ${jobData["$1:HOME"]}" 2>"$tmpDir/error.log-job-$1"
    changeStatus "$1" "NOSTART"
    procInfo "$1" "StartERR"
    return
  fi
fi


  (
    jobIsDone() {
      setLock || exit $err # Could that happens?
      # Calc here not with BYTES but FCOUNT
      modifyJob "$1" "DONE" "$(( 100 * $i / ${jobData["$1:FCOUNT"]} ))%"
      unLock

      # Instead of rm we could finally writeJobStatus, but I think we should
      # only keep a file for running jobs
      rm "$tmpDir/job-status-$1" 2>/dev/null

      exit $err
    }

    writeJobStatus() {
      printf "[Job: %3s, %4s] [Done: %3s%%] [ToDo: Files: %s, Bytes: %s]\n"  \
        "$1" "${jobData["$1:SIZE"]}"                        \
        "$(( 100 * $total / ${jobData["$1:BYTES"]} ))"      \
        "$(( ${jobData["$1:FCOUNT"]} - $i ))"               \
        "$(( ${jobData["$1:BYTES"]} - $total ))"            \
        > "$tmpDir/job-status-$1" ;
    }

    local total="0" err="0" i="0"
    while read size file
    do
      (( i++ ))
      local cmd="cp ${jobData["$1:CPYOPT"]} ${file@Q} ${jobData["$1:TARGET"]@Q}"

if (( optSimulation )) ; then
      # Using logarithm of file size as sleep time
      # https://stackoverflow.com/a/7962297
      local st=$(echo "scale=2; l($size)/l(8)" | bc -l)
      (( size )) || st="1" # When size is 0, log is negative, and then grumble sleep

      case "$(($RANDOM % 9))" in
        2)  cmd2="echo ERRORJob $1; sleep 1; echo 'What ever was wrong' >&2; exit 1;" ; ;;
        *)  cmd2="echo 'SLEEPJob $1 - ${st}s with file: ($size) $file'; sleep ${st};" ; ;;
      esac

      printf "%(%FT%T)T [Job $1]\nFake Job: %s\nTrue Job: %s\n\n" "-1" \
        "$cmd2" "$cmd" >> "$tmpDir/job.log"

      cmd="$cmd2"

else
      printf "%(%FT%T)T [Job $1] %s\n" "-1" "$cmd" >> "$tmpDir/job.log"

fi
      (eval $cmd) >>"$tmpDir/msg.log-job-$1" 2>>"$tmpDir/error.log-job-$1"

      if (( $? )) ; then
        err="1"
        printf "%(%FT%T)T [Job $1] ${txtBold}Trouble${txtClean} with file: %s\n" \
          "-1" "$file" >> "$tmpDir/job.log"
      else
        let total+=size
      fi

      if (( $SECONDS > 0 )) ; then
        # Doing modifyJob here may be expensive, we waste already
        # a lot of time. TODO:If we want an updated jobFile we could
        # parse the job-status files in the daemon idle time
        writeJobStatus "$1"
        SECONDS="0"
      fi

    done < "$tmpDir/job-files-$1"

    # Only without errors display 100% copied, FIXME but if we have an error the display may not correct
    (( err )) || i="${jobData["$1:FCOUNT"]}"

    jobIsDone $1
  )&


  cd "$OLDPWD"
  jobPids[$1]="$!"
  modifyJob "$1" "PID" "$!" # FIXME: After a quick error would that be a wrong info
}

check4Pid() {
  # Need parms: id action
  if ! (( ${jobPids[$1]} )) ; then
    # Should never be printed
    error "FATAL: Job $1 is not in my pid list. Can't $2 job"
    return 1
  fi

  return 0
}

stopJob() {
  # Need parms: id
  procInfo "$1" "Stop"
  check4Pid $1 "stop" || return
  changeStatus "$1" "STOPPED"
  kill -STOP "${jobPids[$1]}"
}

resumeJob() {
  # Need parms: id
  procInfo "$1" "Resume"
  check4Pid $1 "resume" || return
  changeStatus "$1" "running"
  kill -CONT "${jobPids[$1]}"
}

cancelJob() {
  # Need parms: id
  if (( ${jobPids[$1]} )) ; then
    # >>>>>> Don't bother with kill-notice, Thanks to pix
    # https://stackoverflow.com/a/23645819
    # Anyway is it ugly because we don't get this way the 137 exit code in
    # checkChilds. And to avoid to get twice a procInfo we remove the pid first
    local pid=${jobPids[$1]}
    unset jobData["$1:PID"]
    unset jobPids[$1]
    disown "$pid" 2>/dev/null
    kill -KILL "$pid" 2>/dev/null
    changeStatus "$1" "killed"
    procInfo "$1" "Killed"
    modifyJob "$1" "PID" " "
    # <<<<<< end ugly
    # >>>>>> That's all what here should be done
    # kill -KILL "${jobPids[$1]}"
    # modifyJob "$1" "PID" " "
    # <<<<<< end good!
  else
    procInfo "$1" "Cancel"
    changeStatus "$1" "canceled"
  fi
}

procInfo() {
  # Need parms: id change
  local format="%-8s[%3s] [%-15s] %20s <- %s"

  local target="${jobData["$1:TARGET"]}"
  cutLeft "20" target

  printf -v txt "$format" "$2" "$1" "${jobData["$1:DRIVE"]}" \
                "$target" "${jobData["$1:FILES"]}"

  info "%s\n" "$clearLine$txt"
}

checkChilds() {
  # Thanks to michaelt
  # https://stackoverflow.com/a/21750255
  for id in ${!jobPids[*]}; do
    local pid=${jobPids[$id]}
    if kill -0 $pid 2>/dev/null ; then
      # Set job to running if not already done
      [[ ${jobData["$id:PID"]} ]] && continue
      changeStatus "$id" "running"
      jobData["$id:PID"]="$pid"
    else
      recheckJobList="1"
      wait $pid 2>/dev/null
      local x=$?
#       echo ">>Finished>$id<$pid:x=$x<<"
      if (( x == 0 )) ; then
        changeStatus "$id" "done"
        procInfo "$id" "Done"
      else
        if (( x == 127 )) ; then
          # Start up error, should never happens
          changeStatus "$id" "NOSTART"
          procInfo "$id" "StartERR"
        elif (( x == 137 )) ; then
          changeStatus "$id" "killed"
          procInfo "$id" "Killed"
        else
          # Error while running
          changeStatus "$id" "ERROR"
          procInfo "$id" "ERROR"
        fi
      fi

      unset jobData["$id:PID"]
      unset jobPids[$id]
    fi
  done
}

processJobList() {
  recheckJobList="0"
  [[ -s "$jobFile" ]] || return

  setLock || { error "List not processed"; return 1; }
  updateJobList
  setScreenWidth

  local busyDrives=()
  local stoppedJobs=()
  local waitingJobs=()

  while read id prio date status drive
  do
    case $prio in
      0)  case $status in
            STOPPING) stopJob "$id"; stoppedJobs+=($id); ;;
            CANCEL)   cancelJob "$id"; ;;
            *)        error "FATAL: Ignored: ID:$id PRIO:$prio STATUS:$status"; ;;
          esac
      ;;

      1)  busyDrives+=($drive)
      ;;

      2)  case $status in
            RESUME)   if [[ ${busyDrives[@]} =~ $drive ]] ; then
                        waitingJobs+=($id)
                      else
                        busyDrives+=($drive); resumeJob "$id"
                      fi; ;;
            STOPPED)  stoppedJobs+=($id); ;;
            *)        error "FATAL: Ignored: ID:$id PRIO:$prio STATUS:$status"; ;;
          esac
      ;;

      [3-7])
          if [[ ${busyDrives[@]} =~ $drive ]] ; then
            waitingJobs+=($id)
          else
            (( ! stopRunning )) && { busyDrives+=($drive); startJob "$id"; }
          fi
      ;;

      8|9)  # No more todo, only done and canceled jobs left
          break
      ;;

      *)  # Should never happens
          error "FATAL: Ignored: ID:$id PRIO:$prio STATUS:$status"
      ;;

    esac

    (( recheckJobList )) && break

  done < "$jobList"

  unLock

  printf -v running "[Running: %s]" "${!jobPids[*]}"
  printf -v busydrv "[Busy Drives: %s]" "${busyDrives[*]}"
  printf -v stopped "[Stopped: %s]" "${stoppedJobs[*]}"
  printf -v waiting "[Waiting: %s]" "${waitingJobs[*]}"
  printf -v txt "%s %s %s %s" "$running" "$stopped" "$waiting" "$busydrv"

  info "%s\r" "$txt"
  (( optSimulation )) && local simOrNot="${txtBold}* SIMULATION *${txtClean} "
  printf "%s\n" "$simOrNot$txt" > "$tmpDir/processStatus"

  # Let's do some fancy stuff
  local x=("-" "\\" "|" "/")  i="0"
  while (( ${#jobPids[*]} && ! recheckJobList ))
  do
    info "%s\r" "${x[((i++ % 4))]}"
    sleep 0.3
  done

  info "$clearLine"
}

cmdNewJob() {
  [[ -d "$1" ]] || exitError "Destination is not a directory: $1"
  check4PosInteger "$optUserPrio"
  (( optUserPrio > 3 )) && { info "Adjust <user-prio> to 3\n"; optUserPrio="3"; }

  # Get the destination drive
  # FIXME: As long we have plain drives all is nice, but with mappers, raid or
  # what ever other hell, I think there is now way to get the real drive(?)
  # Therefore we build poor fake drives as workaround
  local drive=$(df -P "$1" | tail -n1 | cut -d' ' -f1)   # Now /dev/foo/drive123
  if [[ "$drive" =~ /dev/mapper ]] ; then
    drive=${drive#/dev/mapper/}
    drive=${drive:0:13}                   # Use only first part of full name
# elif FIXME fill me
  else
    drive=${drive%%[0-9]*}                # Drive only matters, not partition
  fi

  local target=$(realpath "$1") ; shift

  if (( optMerge || optRecursive )) ; then
    isGNUcopy || exitError "No GNU copy, no option -m/-r, sorry"
  fi

  if [[ -z "$optExtraCopy" ]] ; then
    if (( optMerge )) ; then
      copyOptions="$copyOptions --backup=numbered"
    elif (( optRecursive )) ; then
      copyOptions="$copyOptions --parents"
    fi
  else
    optRecursive="0"
    copyOptions="$optExtraCopy"
  fi

  checkTmpDir
  newJobFiles=$(mktemp --tmpdir="$tmpDir" new-job-files.XXXX)
  trap "rm $newJobFiles" EXIT

  # FIXME:Get rid of this ugly construct and do it somehow in one loop >>>
  addSourceFile() {
    [[ ! -e "$1" ]] && exitError "File not found: $1"

    if [[ -z "$optExtraCopy" ]] && [[ -d "$1" ]] ; then
      if (( ! optRecursive )) ; then
        # Remove directories from file list. They would only cause
        # warnings when running cp without -r
        info "Omitted: $1\n"
        return
      else
        find "$1" -type f -printf "%s\t%p\n" >> "$newJobFiles"
      fi
      return
    fi

    local size=$(stat -c%s "$1")
    printf "$size\t$1\n" >> "$newJobFiles"
  }
  if (( $# )) ; then
    # Read arguments from command line
    for file        ; do addSourceFile "$file"; done
  else
    # Read from file, when given, otherwise from stdin
    (( ${#optSourceList} )) && exec <"$optSourceList"
    while read file ; do addSourceFile "$file"; done
  fi
  # <<< FIXME:Get rid of this...

  [[ -s "$newJobFiles" ]] || exitError "No files to copy"
  # Don't copy files twice
  # Remove leading ./ from files, ensure file names match and looks nicer
  sed -e "s/\t\.\//\t/" "$newJobFiles" | sort -rn | uniq > "$newJobFiles-uniq"
  mv -f "$newJobFiles-uniq" "$newJobFiles"

  # Collect some statistics
  local count=$(wc -l "$newJobFiles" | cut -d' ' -f1)
  # Thanks Dimitre, https://stackoverflow.com/a/3096575
  local bytes=$(cut -f1 "$newJobFiles" | paste -sd+ | bc)

  # Build small file list only for user hint
  local files=$(cut -f2 "$newJobFiles" | head -n20 | paste -sd';')
  # 200 is arbitrary chosen, long enough to fill one line
  (( ${#files} > 200 )) && files="${files:0:199}~"

  setLock || exitError "Job not added"

  newId=$(nextJobId)
  local total=$(numfmt --to=si $bytes)
  local bytesPerFile=$(( bytes / count ))

  out "%s" "New job: $newId - PRIO $(( 6 - optUserPrio )) " \
      "($count files, $total total, $(numfmt --to=si $bytesPerFile) avg size)"
  out "Target : $target"
  out "Files  : ${files}"
  if [[ -n "$optExtraCopy" ]] ; then
  out "Note   : Listed job data may differ due to given special cp options"
  fi
  if (( ${#copyOptions} )) ; then
  out "Options: $copyOptions"
  fi

  mv "$newJobFiles" "$tmpDir/job-files-$newId"

  # PRIOrity is associated to STATUS as follows
  # STOPPING RESUME CANCEL running stopped pending error/kill/canceled done
  #    0        0     0        1      2      3-7           8             9
  addToJobFile "$newId" "PRIO" "$(( 6 - optUserPrio ))"
  addToJobFile "$newId" "STATUS" "pending"
  addToJobFile "$newId" "DONE" "0%"
  printf -v date "%(%FT%T)T" "-1"
  addToJobFile "$newId" "DATE" "$date"
  addToJobFile "$newId" "DRIVE" "$drive"
  addToJobFile "$newId" "HOME" "$PWD"        # Needed, the daemon run in /
  addToJobFile "$newId" "TARGET" "$target"
  addToJobFile "$newId" "FILES" "$files"
  addToJobFile "$newId" "FCOUNT" "$count"
  addToJobFile "$newId" "BYTES" "$bytes"
  addToJobFile "$newId" "SIZE" "$total"
  addToJobFile "$newId" "CPYOPT" "$copyOptions"

  unLock

  trap - EXIT

  notifyDaemon
}

#
# Begin Main
#

# This cut the help output too, not what someone may endorse, but it show so
# lovely how nice the new cutting works ;-p
setScreenWidth

# Hint the user how to use me when called without argument
[ "$#" -eq "0"  ] && set -- "-h"

while getopts :Hhc: opt # Keep help recognition away from other options
do
  case $opt in
    h)  if   [[ "-hl" == $1 || "l" == $2 ]] ; then opt="l"
        elif [[ "-hs" == $1 || "s" == $2 ]] ; then opt="s"; fi; ;;
    H) : ; ;;
    c)  optForcedScreenSize="1"
        check4Integer "$OPTARG"
        screenWidth="$OPTARG"
        continue; ;;

    *)  continue; ;;
  esac

  cmdHelp "$opt"
  exit 0
done

OPTIND="1"
while getopts ac:f:hi:mo:p:rs opt
do
  case $opt in
    a)  optStartDaemon="1"               ; ;;
    f)  [[ -f "$OPTARG" ]] || exitError "File not found: $OPTARG"
        optSourceList="$OPTARG"          ; ;;
    i)  check4Integer "$OPTARG"
        optIdleTime="$OPTARG"            ; ;;
    m)  optMerge="1"                     ; ;;
    o)  optExtraCopy="$OPTARG"           ; ;;
    p)  optUserPrio="$OPTARG"            ; ;;
    r)  optRecursive="1"                 ; ;;
    s)  optSimulation="1"                ; ;;

    \?) exitError "Need help? Use: $me -h"  ; ;;
  esac
done

shift $(( $OPTIND - 1 ))

(( isAlterEgo )) && { cmdNewJob "$@"; exit 0; }

# Catch some funny guys
(( $# )) && { cmd="$1"; shift; } || cmd="h"

if   [[ "H"               == "$cmd" ]] ; then cmdHelp "H"
elif [[ "h"               == "$cmd" ]] ; then cmdHelp "$@"
elif [[ "hl"              == "$cmd" ]] ; then cmdHelp "l"
elif [[ "hs"              == "$cmd" ]] ; then cmdHelp "s"
elif [[ "K"               == "$cmd" ]] ; then cmdKill "$@"
elif [[ "$cmd"          =~ K[1-9]+$ ]] ; then cmdKill "${cmd:1}" "$@"
elif [[ "P"               == "$cmd" ]] ; then cmdProcess
elif [[ "Y"               == "$cmd" ]] ; then cmdTidy
elif [[ "p"               == "$cmd" ]] ; then cmdChangePrio "$@"
elif [[ "$cmd"     =~ p[+-]?[1-9]?$ ]] ; then cmdChangePrio "${cmd:1}" "$@"
elif [[ "r"               == "$cmd" ]] ; then cmdResume "$@"
elif [[ "$cmd"          =~ r[1-9]+$ ]] ; then cmdResume "${cmd:1}" "$@"
elif [[ "s"               == "$cmd" ]] ; then cmdStop "$@"
elif [[ "$cmd"          =~ s[1-9]+$ ]] ; then cmdStop "${cmd:1}" "$@"
elif [[ "w"               == "$cmd" ]] ; then cmdShow "$@"
elif [[ "we"              == "$cmd" ]] ; then cmdShow "e"
elif [[ "wi"              == "$cmd" ]] ; then cmdShow "i"
elif [[ "wl"              == "$cmd" ]] ; then cmdShow "l"
elif [[ "ws"              == "$cmd" ]] ; then cmdShow "s"
elif [[ "X"               == "$cmd" ]] ; then cmdExit
elif (( ${#cmd} == 1 )) ; then exitError "Unknown short command: $cmd"
elif [[ "exit"            =~ "$cmd" ]] ; then cmdExit
elif [[ "kill"            =~ "$cmd" ]] ; then cmdKill "$@"
elif [[ "newjob"          =~ "$cmd" ]] ; then cmdNewJob "$@"
elif [[ "prio"            =~ "$cmd" ]] ; then cmdChangePrio "$@"
elif [[ "process"         =~ "$cmd" ]] ; then cmdProcess
elif [[ "resume"          =~ "$cmd" ]] ; then cmdResume "$@"
elif [[ "show"            =~ "$cmd" ]] ; then cmdShow "$@"
elif [[ "start"           =~ "$cmd" ]] ; then cmdStartDaemon "$@"
elif [[ "status"          =~ "$cmd" ]] ; then cmdStatus
elif [[ "stop"            =~ "$cmd" ]] ; then cmdStop "$@"
elif [[ "tidy"            =~ "$cmd" ]] ; then cmdTidy
else exitError "Unknown command: $cmd"
fi

exit 0
